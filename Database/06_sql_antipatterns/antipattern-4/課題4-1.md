## 課題4-1

ツリー構造をリレーショナルデータベースで表現する際（例えばslackのようなスレッドを表現する時など）に、以下のように親の ID だけを持つツリー構造を見かけることがあります。

```sql
TABLE Message {
  id: varchar
  parent_message_id: varchar
  text: varchar
  FOREIGN KEY (parent_message_id) REFERENCES Message(id)
}
```

上記の設計では`parent_message_id`にMessage自身のidを持つ、自己参照を用いています。

この設計だとどのような問題が生じるか、説明してください。

### アンチパターンの詳細

アンチパターン書籍、2章 ナイブツリー(素朴な木)に記載。

複数の親テーブルを参照する状態をポリモーフィック関連という。

### 問題点

#### 1.ツリー構造を辿るのが難しい（再帰的なクエリが必要）

あるメッセージにぶら下がっているすべての返信を取得したい場合

例えばメッセージID m1 に対して：
```
m1
├─ m2
│  └─ m3
│     └─ m4
└─ m5
```
- SQLで取得するには、「m1 の子（m2、m5）、その子の子（m3）、…」と何回も JOIN を重ねるか、再帰クエリを使う必要がある。

#### 2.階層の深さ（レベル）がわからない

```
m1
  └ m2
     └ m3
```

深さ情報がテーブルに含まれていないため、再帰的に親を辿ってカウントしないと「今どの階層か」がわからない。
→ UI側で階層を表示するのが難しい

#### 3.祖先・子孫の一覧を効率的に取得できない

このメッセージにぶら下がってるすべてのメッセージを一覧表示したい場合

```
m1
├─ m2
│  └─ m3
│     └─ m4
└─ m5
→ m1 にぶら下がる子孫：m2, m3, m4, m5
```

- 親を見ていく（1段）なら簡単。でも すべての子孫を探すには再帰が必要。
パフォーマンスも悪くなる。

#### 4.循環参照（ループ）の危険性がある

誤って、m3 の親に m4 を指定 → m4 の親は m3 → ループ完成

```
m3 → m4 → m3 → m4 → …（無限ループ）
```
- RDBMSの外部キー制約ではこの循環を検知できない
- アプリケーションで「自分自身や子孫を親に指定しない」制御が必要

#### 5.削除や移動の影響が大きい

m1 を削除したい → m2, m3, m4, m5 も削除すべき
1件だけ削除すると「ぶら下がったメッセージが孤立」してしまう

再帰的に削除対象を収集するロジックが必要（アプリ or 再帰クエリ）

ON DELETE CASCADEを使用することで、親メッセージが削除された際に子メッセージも自動的に削除されるように設定することは可能ではあるが、ノードの昇格や移動は自動化できないから結局つらいイメージ。
